/*
	Glidix kernel

	Copyright (c) 2014-2017, Madd Games.
	All rights reserved.
	
	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions are met:
	
	* Redistributions of source code must retain the above copyright notice, this
	  list of conditions and the following disclaimer.
	
	* Redistributions in binary form must reproduce the above copyright notice,
	  this list of conditions and the following disclaimer in the documentation
	  and/or other materials provided with the distribution.
	
	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
	FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
	DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
	SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
	OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef FATFS_H_
#define FATFS_H_

#include <glidix/util/common.h>

#define	FAT_ATTR_RDONLY			(1 << 0)
#define	FAT_ATTR_HIDDEN			(1 << 1)
#define	FAT_ATTR_SYSTEM			(1 << 2)
#define	FAT_ATTR_VOLUME_ID		(1 << 3)
#define	FAT_ATTR_DIR			(1 << 4)
#define	FAT_ATTR_ARCHIVE		(1 << 5)

#define	FAT_ATTR_LFN			0x0F

typedef struct
{
	/* BPB */
	uint8_t				jump[3];
	char				oemid[8];
	uint16_t			sectorSize;
	uint8_t				sectorsPerCluster;
	uint16_t			reservedSectors;
	uint8_t				numFats;
	uint16_t			ndents;			/* zero for FAT32 */
	uint16_t			sectorsSmall;
	uint8_t				mediaType;
	uint16_t			sectorsPerFatOld;	/* not valid for FAT32 */
	uint16_t			sectorsPerTrack;
	uint16_t			numHeads;
	uint32_t			hiddenSectors;
	uint32_t			sectorsLarge;
	
	/* EBPB */
	uint32_t			sectorsPerFat;
	uint16_t			flags;
	uint16_t			version;
	uint32_t			rootCluster;
	uint16_t			infoSector;
	uint16_t			backupBootSector;
	char				reserved[12];
	uint8_t				drive;
	uint8_t				winNTFlags;
	uint8_t				sig;			/* 0x28 or 0x29 */
	uint32_t			volumeSerial;
	uint8_t				volumeLabel[11];
	uint8_t				systemID[8];
	char				bootCode[420];
	uint16_t			bootsig;		/* 0xAA55 */
} PACKED FATBootRecord;

typedef struct
{
	char				filename[11];
	uint8_t				attr;
	uint8_t				winnt;
	uint8_t				creatSecs;
	uint16_t			creatTime;
	uint16_t			creatDate;
	uint16_t			accessDate;
	uint16_t			clusterHigh;
	uint16_t			modTime;
	uint16_t			modDate;
	uint16_t			clusterLow;
	uint32_t			size;
} PACKED FATDent;

typedef struct
{
	uint8_t				seqno;
	uint16_t			firstChars[5];
	uint8_t				attr;			/* == FAT_ATTR_LFN */
	uint8_t				type;			/* == 0 */
	uint8_t				checksum;
	uint16_t			nextChars[6];
	uint16_t			zero;
	uint16_t			finalChars[2];
} PACKED FATLongEntry;

/**
 * Entry in the "virtual inode table". This maps inode numbers generated by the driver
 * to information on the FAT volume.
 */
typedef struct FATInodeTable_
{
	/**
	 * Link.
	 */
	struct FATInodeTable_*		next;
	
	/**
	 * Inode number. This is generated by the driver rather than actually taken from disk.
	 */
	ino_t				ino;
	
	/**
	 * Byte offset into the partition, pointing to the 8.3 directory entry which describes
	 * this inode. This is used to delete the directory entries (by setting the first byte
	 * in the name to the 'deleted' value) when necessary, as well as allowing updates to
	 * the metadata such as size. If zero, then there is no directory entry (e.g. root
	 * directory or newly created inode). This can change if the directory is flushed to
	 * disk and written in a different order (for example if another entry is deleted).
	 */
	off_t				dentpos;
	
	/**
	 * List of allocated clusters and the chain size.
	 */
	uint32_t*			clusters;
	size_t				numClusters;
	
	/**
	 * The filesystem to which this inode belongs.
	 */
	struct Fatfs_*			fatfs;
	
	/**
	 * Size and attributes, in case the inode is not loaded and we're writing a directory entry.
	 */
	uint32_t			csize;
	uint8_t				cattr;
} FATInodeTable;

/**
 * FAT filesystem data.
 */
typedef struct Fatfs_
{
	/**
	 * Filesystem image handle.
	 */
	File*				fp;
	
	/**
	 * The VBR.
	 */
	FATBootRecord			vbr;
	
	/**
	 * Byte offset to the FAT.
	 */
	off_t				fatpos;
	
	/**
	 * Next virtual inode number to allocate.
	 */
	ino_t				nextIno;
	
	/**
	 * Virtual inode table, first entry.
	 */
	FATInodeTable*			itab;
	
	/**
	 * Lock.
	 */
	Semaphore			lock;
	
	/**
	 * Size of a cluster in bytes.
	 */
	size_t				clusterSize;
	
	/**
	 * Offset to the beginning of clusters.
	 */
	off_t				clusterPos;
	
	/**
	 * Number of clusters in the volume.
	 */
	size_t				numClusters;
	
	/**
	 * The VFS filesystem description.
	 */
	FileSystem*			fs;
} Fatfs;

#endif
